<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Comparison of methods for calculating conditional expectations of sufficient statistics for continuous time Markov chains</title>
<meta name="Subject" content="BMC Bioinformatics 2011, 12:465. doi:10.1186/1471-2105-12-465"/>
<meta name="Keywords" content=" "/>
<meta name="Author" content="Paula Tataru"/>
<meta name="Creator" content="Arbortext Advanced Print Publisher 10.0.1082/W Unicode"/>
<meta name="Producer" content="Acrobat Distiller 9.4.2 (Windows)"/>
<meta name="CreationDate" content=""/>
</head>
<body>
<pre>
Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

METHODOLOGY ARTICLE

Open Access

Comparison of methods for calculating
conditional expectations of sufficient statistics for
continuous time Markov chains
Paula Tataru* and Asger Hobolth

Abstract
Background: Continuous time Markov chains (CTMCs) is a widely used model for describing the evolution of DNA
sequences on the nucleotide, amino acid or codon level. The sufficient statistics for CTMCs are the time spent in a
state and the number of changes between any two states. In applications past evolutionary events (exact times
and types of changes) are unaccessible and the past must be inferred from DNA sequence data observed in the
present.
Results: We describe and implement three algorithms for computing linear combinations of expected values of
the sufficient statistics, conditioned on the end-points of the chain, and compare their performance with respect to
accuracy and running time. The first algorithm is based on an eigenvalue decomposition of the rate matrix (EVD),
the second on uniformization (UNI), and the third on integrals of matrix exponentials (EXPM). The implementation
in R of the algorithms is available at http://www.birc.au.dk/~paula/.
Conclusions: We use two different models to analyze the accuracy and eight experiments to investigate the
speed of the three algorithms. We find that they have similar accuracy and that EXPM is the slowest method.
Furthermore we find that UNI is usually faster than EVD.

Background
In this paper we consider the problem of calculating the
expected time spent in a state and the expected number
of jumps between any two states in discretely observed
continuous time Markov chains (CTMCs). The case
where the CTMC is only recorded at discretely observed
time points arises in molecular evolution where DNA
sequence data is extracted at present day and past evolutionary events are missing. In this situation, efficient
methods for calculating these types of expectations are
needed. In particular, two classes of applications can be
identified.
The first class of applications is concerned with rate
matrix estimation. [1] describes how the expectationmaximization (EM) algorithm can be applied to estimate
the rate matrix from DNA sequence data observed in
the leaves of an evolutionary tree. The EM algorithm is
implemented in the software XRate [2] and has been
* Correspondence: paula@birc.au.dk
Bioinformatics Research Center, Aarhus University, Aarhus, Denmark

applied in [3] for estimating empirical codon rate
matrices. [1] uses the eigenvalue decomposition of the
rate matrix to calculate the expected time spent in a
state and the expected number of jumps between states.
The second class of applications is concerned with
understanding and testing various aspects of evolutionary trajectories. In [4] it is emphasized that analytical
results for jump numbers are superior to simulation
approaches and various applications of jump number
statistics are provided, including a test for the hypothesis that a trait changed its state no more than once in
its evolutionary history and a diagnostic tool to measure
discrepancies between the data and the model. [4]
assumes that the rate matrix is diagonalizable and that
the eigenvalues are real, and applies a spectral representation of the transition probability matrix to obtain the
expected number of state changes.
[5] and [6] describe a method, termed substitution
mapping, for detecting coevolution of evolutionary traits,
and a similar method is described in [7]. The substitution mapping method is based on the expected number

© 2011 Tataru and Hobolth; licensee BioMed Central Ltd. This is an Open Access article distributed under the terms of the Creative
Commons Attribution License (http://creativecommons.org/licenses/by/2.0), which permits unrestricted use, distribution, and
reproduction in any medium, provided the original work is properly cited.

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

of substitutions while [7] base their statistics on the
expected time spent in a state. Furthermore [7]
describes an application concerned with mapping synonymous and non-synonymous mutations on branches of a
phylogenetic tree and employs the expected number of
changes between any two states for this purpose. [8]
uses the expected number of state changes to calculate
certain labeled evolutionary distances. A labeled evolutionary distance could for example be the number of
state changes from or to a specific nucleotide. In [9]
substitution mapping is invoked for identifying biochemically constrained sites. In [7] and [8] the summary
statistics are calculated using the eigenvalue decomposition method suggested by [1]. In [5,6] and [9] the substitution mapping is achieved using a more direct
formula for calculating the number of state changes. In
this direct approach an infinite sum must be truncated
and it is difficult to control the error associated with the
truncation. An alternative is described in [10] where
uniformization is applied to obtain the expected number
of jumps. [10] uses the expected number of jumps on a
branch to detect lineages in a phylogenetic tree that are
under selection.
A third algorithm for obtaining the number of
changes or time spent in a state is outlined in [11]. The
algorithm is based on [12] where a method for calculating integrals of matrix exponentials is described. A natural question arises: which of the three methods
(eigenvalue decomposition, uniformization or matrix
exponentiation) for calculating conditional expectations
of summary statistics for a discretely observed CTMC
should be preferred? The aim of this paper is to provide
an answer to this question. We describe and compare
the three methods. Our implementations in R [13] are
available at http://www.birc.au.dk/~paula/. (Furthermore
the eigenvalue decomposition and uniformization methods are also available as a C++ class in the bio++ library
at http://biopp.univ-montp2.fr/.) The performance and
discussion of the algorithms are centered around two
applications. The first application is concerned with rate
matrix estimation; we estimate the Goldman-Yang
codon model [14] using the expectation-maximization
algorithm. The second application is based on the
labeled distance estimation presented in [8].
Consider a stochastic process {X(s): 0 ≤ s ≤ t} which
can be described by a CTMC with n states and an n × n
rate matrix Q = (qcd). The off-diagonal entries in Q are
non-negative and rows sum to zero, i.e. qcc = - Σd≠c qcd
= -qc. Maximum likelihood estimation of the rate matrix
from a complete observation of the process is straight
forward. The likelihood of the process, conditional on
the beginning state X(0), is given by (e.g. [15])

Page 2 of 11

⎛
qc Tc ⎝

L(Q; {X(s) : 0 ≤ s ≤ t}) = exp −
c

⎞

n

qNcd ⎠ ,
cd

(1)

c=1 d=c

where Tc is the total time spent in state c and Ncd is
the number of jumps from c to d. The necessary sufficient statistics for a CTMC are thus the time spent in
each state and the number of jumps between any two
states. In applications, however, access is limited to
DNA data from extant species. The CTMC is discretely
observed and we must estimate the mean values of Tc
and Ncd conditional on the end-points X(0) = a and X(t)
= b. From [15] we have that

E[Tc |X(0) = a, X(t) = b] = E[Tc |t, a, b] =

ab
Icc (t)
pab (t)

E[Ncd |X(0) = a, X(t) = b] = E[Ncd |t, a, b] =

(2)

ab
qcd Icd (t)
(3)
pab (t)

where P(t) = (pij(t)) = eQt is the transition probability
matrix and
t

ab
Icd (t) = ∫ pac (u)pdb (t − u)du.

(4)

0

Many applications require a linear combination of certain substitutions or times. Examples include the number
of transitions, transversions, synonymous and non-synonymous substitutions. In the two applications described
below the statistics of interest is a linear combination of
certain substitutions and times. Let therefore C be an n ×
n matrix and denote by Σ(C; t) the matrix with entries
ab
Ccd Icd (t).

(C; a, b, t) =

(5)

c,d

We describe, compare and discuss three methods for
calculating Σ(C; t). The evaluation of the integrals (4)
takes O(n 3 ) time and therefore a naive calculation,
assuming that C contains just one entry different from
zero has a O(n5) running time. Even worse, if C contains
O(n2) entries different from zero, then the naive implementation has a O(n7) running time. For all three methods our implementations of Σ(C; t) run in O(n3) time.

Results
Applications
Application 1: Rate matrix estimation

Our first application is the problem of estimating the
parameters in a CTMC for evolution of coding DNA
sequences which we describe using the 61 × 61 rate
matrix (excluding stop codons) given by Goldman and
Yang [14]:

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

⎧
⎪0
⎪
⎪
⎪ ακπj
⎨
qij = απj
⎪
⎪ αωκπj
⎪
⎪
⎩
αωπj

Page 3 of 11

if there is more than one difference between codons i and j
if j is obtained from i by a synonymous transition
if j is obtained from i by a synonymous transversion
(6)
if j is obtained from i by a non - synonymous transition
if j is obtained from i by a non - synonymous transversion

where π is the stationary distribution,  is the transition/transversion rate ratio, ω is the non-synonymous/
synonymous ratio and a is a scaling factor. The stationary distribution π is determined directly from the data
using the codon frequencies. We estimate the remaining
parameters θ = (a, , ω) using the expectation-maximization (EM) algorithm [16] as described below.
Suppose the complete data x is available, consisting of
times and types of substitutions in all sites and in all
branches of the tree. The complete data log likelihood
is, using (1) and (6),
(α, κ, ω; x) = −αLs,tv − αωLns,tv − ακLs,ts − ακωLns,ts
+ N log α + Nts log κ + Nns log ω,

(7)

where we use the notation
Ls,ts =

πi 1((i, j) ∈ Ls,ts ) and Nts =

Ti
i

j

Nij 1((i, j) ∈ Lts )
i,j

parameters are updated by maximizing G(θ; θ0,y). The
parameters converge to a local maximum of the likelihood for the observed data.
The expected log likelihood conditional on the data y
and under the three parameters a,  and ω is
E[ (α, κ, ω; x)|y] = −α E[Ls,tv |y] − αωE[Lns,tv |y]
− ακ E[Ls,ts |y] − ακωE[Lns,ts |y]

Therefore the E-step requires expectations of linear
combinations of waiting times in a set of states and
number of jumps between certain states. Because of the
Markov property this calculation can be divided in two
parts. First we use the peeling algorithm [17,18] to
obtain the probability P(γk = a, βk = b|y, tk ) that a branch
k of length tk with nodes gk and bk above and below the
branch, respectively, has end-points a and b. Second, we
calculate the desired summary statistic by summing over
all branches. For example we have
E[Ls,ts |y] =

(8)

where e.g.

branch k a,b

E[Nts |y] =
branch k a,b

Ls,ts = {(i, j) : i and j differ at one position and the substitution of i with j is a synonymous transition}.

A similar notation applies for L s,tv , Lns,ts , Lns , tv , Nns
and N, where the last statistic is the sum of substitutions between all states (i, j) that differ at one position
and s, ns, ts and tv subscripts stand for synonymous,
non-synonymous, transition and transversion.
The complete data log likelihood can be maximized
easily by making the re-parametrization b = a. We
find that
α=
ˆ

√
Ntv
Nts
−b + b2 − 4ac
ˆ
,β =
and ω =
ˆ
,
Ls,tv + ωLns,tv
ˆ
Ls,ts + ωLns,ts
ˆ
2a

(9)

where a = -Lns,tvLns,tsNs, b = Lns,tvLs,ts(Nns - Ntv) + Lns,
Ls,tv(Nns - Nts) and c = Ls,tvLs,tsNns.
ts
In reality the data y is only available in the leaves and
the times and types of substitutions in all sites and all
branches of the tree are unaccessible. The EM algorithm
is an efficient tool for maximum likelihood estimation
in problems where the complete data log likelihood is
analytically tractable but full information about the data
is missing.
The EM algorithm is an iterative procedure consisting
of two steps. In the E-step the expected complete log
likelihood
G(θ ; θ0 , y) = Eθ0 [ (θ ; x)|y]

(10)

conditional on the data y and the current estimate of
the parameters θ 0 is calculated. In the M-step the

(11)

+ E[N|y]logα + E[Nts |y]logκ + E[Nns |y]logω.

P(γk = a, βk = b|y, tk )E[Ls,ts |tk , a, b](12)
P(γk = a, βk = b|y, tk )E[Nts |tk , a, b].(13)

The E-step thus consists of calculating conditional
expectations of linear combinations of times such as
E[Ls,ts |tk , a, b] and substitutions such as E[Nts |tk , a, b]
where Ls,ts and Nts are given by (8). In our application n
= 61 and the first type of statistics E[Ls,ts |t, a, b] is (up to
a factor p ab (t)) on the form (5) with diagonal entries
Cii =
πj 1((i, j) ∈ Ls,ts ) and all off diagonal entries
j

equal to zero. The second type of statistics E[Nts |t, a, b]
is also on the form (5) with off-diagonal entries
Cij = qij 1((i, j) ∈ Lts ) and zeros on the diagonal.
Application 2: Robust distance estimation

The second application is a new approach for estimating
labeled evolutionary distance, entitled robust counting
and introduced in [8]. The purpose is to calculate a distance that is robust to model misspecification. The
method is applied to labeled distances, for example, the
synonymous distance between two coding DNA
sequences. As it is believed that selection mainly acts at
the protein level, synonymous substitutions are neutral
and phylogenies built on these type of distances are
more likely to reveal the true evolutionary history. The
distance is calculated using the mean numbers of
labeled substitutions conditioned on pairwise site patterns averaged over the empirical distribution of site
patterns observed in the data. In the conventional
method the average is done over the theoretical distribution of site patterns. The robustness is therefore

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 4 of 11

achieved through the usage of more information from
the data and less from the model.
Let Q be the rate matrix of the assumed model, P(t) =
eQt, the labeling be given through a set of pairs L and
the data be represented by a pairwise alignment y = (y1,
y 2 ) of length m. As data only contains information
about the product Qt, where t is the time distance
between the sequences, we can set t = 1.
Suppose we observe the complete data consisting of
the types of substitutions that occurred in all sites and
Nij 1((i, j) ∈ L) be the labeled number of
let NL =
i,j

substitutions. A natural labeled distance is given by
dL = E(NL ). The labeled distance is estimated as the
average across all sites of the expected number of
labeled substitutions conditioned on the observed end
points:
dL =
1
=
m

s=1

1
m

s=1

E[NL |X(0) = y1s , X(1) = y2s ]
m

⎡

⎤

E⎣

m

(14)

i,j

Therefore this application requires evaluating a sum
on the form (5) with off-diagonal entries
Cij = qij 1((i, j) ∈ L) and zeros on the diagonal.
Algorithms
ab
The calculation of Σ(C; t) is based on the integrals Icd (t).
In this section we present three existing methods for
obtaining the integrals and extend them to obtain Σ(C;
t).

Eigenvalue decomposition (EVD)

When the rate matrix Q is diagonalizable, the computaab
tion of transition probabilities pab(t) and integrals Icd (t)
can be done via the eigenvalue decomposition (EVD).
EVD is a widely used method for calculating matrix
exponentials. Let Q = UΛU-1 be the eigenvalue decomposition, with Λ = diag(l1, ..., ln). It follows that
U−1 )t

= Ue t U−1 .

(15)

Because Λ is diagonal, e Λt is also diagonal with
(e t )ii = eλi t.
The integral (4) becomes
Uai (U−1 )ic

ab
Icd (t) =
i

Udj (U−1 )jb Jij (t)
j

(16)

⎧
⎨

teλi t
if λi = λj
λ i t − eλ j t
where Jij (t) = e
if λi = λj .
⎩
λi − λj

Acj =

and

d

Ccd Udj , Bij = Jij (t)

(C; a, b, t) =

i Uai Dib

(U−1 )ic Acj , Dib =

j

Bij (U−1 )jb

we find
(18)

where ○ represents the entry-wise product.
The eigenvalues and eigenvectors might be complex,
but they come in complex conjugate pairs and the final
result is always real; for more information we refer to
the Supplementary Information in [2]. If the CTMC is
reversible, the decomposition can be done on a symmetric matrix obtained from Q (e.g. [15]), which is faster and tends to be more robust. Let π be the stationary
distribution. Due to reversibility, πaqab = πbqba, which
can be written as ΠQ = Q*Π where Π = diag(π). Let S =
Π1/2QΠ-1/2.
We have that
S∗ =

−1/2
−1/2

Q∗

1/2

( Q)

−1/2

=
−1/2

(Q∗ )

=

1/2

Q

−1/2

−1/2

=S

(19)

where S* is the transpose of S. Then S is symmetric.
Let Λ, V be its eigenvalues and eigenvectors, respectively. Then VΛV-1 = S = Π1/2QΠ-1/2, which implies Q =
(Π-1/2V)Λ(V-1Π1/2) and it follows that Q has the same
eigenvalues as S and Π-1/2V for eigenvectors.
The results can be summarized in the following algorithm:
Algorithm 1: EVD
Input: Q, C, t
Output: Σ(C; t)
Step 1: Determine eigenvalues li.
Determine the eigenvectors Ui for Q and
compute U-1.
Step 2: Determine matrix J(t) from (17).
Step 3: Determine matrix Σ(C;t) from (18).
Uniformization (UNI)

The uniformization method was first introduced in [19]
for computing the matrix exponential P(t) = eQt. In [11]
it was shown how this method can be used for calculating summary statistics, even for statistics that cannot be
written in integral form. Let μ = max i (q i ) and
1
R = Q + I, where I is the identity matrix.
μ
Then
P(t) = eμ(R−I)t =

(17)

c

(C; t) = U[J(t) ◦ (U−1 CU)]U−1

=

Ni,j 1((i, j) ∈ L)|1, y1s , y2s ⎦ .

P(t) = eQt = e(U

ab
Replacing Icd (t) with (16) in (5), rearranging the sums
and
using

∞

Rm
m=0

(μt)m −μt
=
e
m!

∞

Rm Pois(m; μt) (20)
m=0

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 5 of 11

where Pois(m; l) is the probability of m occurrences
from a Poisson distribution with mean l. Using (20) we
also have
t

ab
Icd (t) =

pac (u)pdb (t − u)du

0
∞

t

⎡
(μu)i −μu ⎣
(R )ac
e
i!

=
0

i=0
∞

∞

μi+j −μt
(R )ac (R )db
e
i!j!
i

=
i=0 j=0

(Ri )ac (Rj )db
i=0 j=0

1
=
μ

∞

⎤
(μ(t − u))j −μ(t−u) ⎦
(R )db
e
du
j!
j

j=0
t

j

∞

∞

=
1
=
μ

∞

i

ui (t − u)j du

0

(21)

μi+j −μt
i!j!
e
ti+j+1
i!j!
(i + j + 1)!

∞

(Ri )ac (Rj )db
i=0 j=0
∞

(μt)i+j+1 −μt
e
(i + j + 1)!
m

Pois(m + 1; μt)
m=0

(Rl )ac (Rm−l )db .
l=0

Replacing (21) in (5), rearranging the sums and using
m−l ) = (CRm−l )
that
and
d Ccd (R
db
cb
l ) (CRm−l ) = (Rl CRm−l ) we derive
c (R ac
cb
ab
(C; t) =

1
μ

∞

m

Pois(m + 1; μt)
m=0

Rl CRm−l .

(22)

l=0

The main challenge with this method is the infinite
sum and we use (20) to determine a truncation point.
In particular if we let l = μt and truncate at s(l) we
can bound the error using the tail of the Poisson distribution:
∞

s(λ)

pab (t) −

(Rm )ab Pois(m; μt) =
m=0

∞

(Rm )ab Pois(m; μt) ≤
m=s(λ)+1

Pois(m; μt).

∞

s(λ) − λ
√
,
λ

Pois(m; μt) ≈ 1 −

Algorithm 2: UNI
Input: Q, C, t
Output: Σ(C; t)
Step 1: Determine μ, s(μt) and R.
Step 2: Calculate Rm for 2 ≤ m ≤ s(μt).

60
35
10
0

5

m

Step 3: Calculate A(m) =

l=0

Rl CRm−l for 0 ≤ m ≤

s(μt).
using the recursion A(m + 1) = A(m)R + Rm+1C.
Step 4: Determine Σ(C; t) from (22).
Exponentiation (EXPM)

This method for calculating the integral (4) was developed in [12] and emphasized in [11]. Suppose we want
t
to evaluate 0 eQu BeQ(t−u) du, where Q and B are n × n
matrices. To calculate this integral, we use an auxiliary
QB
and the desired integral can be
matrix A =
0Q

truncation value

m=s(λ)

truncation value

the smallest integer greater than or equal to x. In Figure
1 we compare the exact truncation value and the linear
regression approximation.
The linear regression provides an excellent fit to the
tail of the distribution.
In summary we have the following algorithm:

m=s(λ)

We have that, for large values of l, Pois(λ) ≈ N(λ, λ),
where N(μ, σ 2 ) is the normal distribution with mean μ
and variance s2. Therefore, for large l, the error bound
b=

where F(·) is the cumulative distribution function for
the standard normal distribution. Consequently we can
approximate the truncation point s(l) with
√ −1
-8
-1
λ
(1 − b) + λ. If b = 10 we obtain F (1 - b) =
5.6.
Another way to determine s(l) is to use R to evaluate
Pois(m; l) for values of m that gradually increase, until
the tail is at most b = 10 -8 . Combining these two
approaches, we performed a linear regression, approxi√
mating the tails from R by c1 + c2 λ + c3 λ. We obtained
c1 = 4.0731, c2 = 5.6469, c3 = 0.9963 but, in order to be
√
conservative, we use s(λ) = 4 + 6 λ + λ where ⌈x⌉ is

10

15

20

25

30

8
5
2
0.0

0.1

0.2

0.3

0.4

0.5

λ

λ
approximation

exact

√

Figure 1 Poisson truncation. Comparison between the exact truncation value and the 4 + 6 λ + λ approximation. In the plot on the left,
l ranges from 0 to 30, while the plot on the right is a zoom-in for values between 0 to 0.5. The plot shows that the approximation is a
conservative fit of the Poission tail.

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 6 of 11

found in the upper right corner of the matrix exponential of A:
t
0

eQu BeQ(t−u) du = (eAt )1:n,(n+1):2n .

(23)

ab
Icd (t) =

t

pac (u)pdb (t − u)du =

0

0
t

=
0

e 1{(c,d)} e
Qu

Q(t−u)

(eQu )ac (eQ(t−u) )db du

(24)

du
ab

where 1{(c,d)} is a matrix with 1 in entry (c, d) and zero
ab
otherwise. We can use this method to determine Icd (t)
by simply setting B = 1{(c,d)}, construct the auxiliary
matrix A, calculate the matrix exponential of At, and
finally read off the integral in entry (a, b) in the upper
right corner of the matrix exponential.
Replacing (24) in (5) and rearranging the terms we
have
t

(C; t) =
0

Ccd 1{(c,d)} eQ(t−u) du

eQu
c,d

⎧
nt
⎪1 n−1
⎪ +
exp −
if i = j
⎨
n
n
n−1
nt
⎪ 1 1
⎪
− exp −
if i = j
⎩
n n
n−1
⎧
nt
2(n − 1)
nt
⎪
⎪
−
1 − exp −
⎪ t + t exp −
⎪
n−1
n
n−1
⎪
⎪
1 ⎨
nt
2(n − 1)2
nt
ab
and Icd (t) = 2 t + (n − 1)2 t exp −
+
1 − exp −
n ⎪
n−1
n
n−1
⎪
⎪
⎪
nt
(n − 2)(n − 1)
nt
⎪
⎪ t − (n − 1)t exp −
⎩
+
1 − exp −
n−1
n
n−1
pij (t) =

We are interested in
t

Q has two unique eigenvalues: 0 with multiplicity 1
n
and −
with multiplicity n-1. We obtain
n−1

Ccd 1{(c,d)} = C.

and

(25)

c,d

Therefore by setting B = C in the auxiliary matrix we
obtain Σ(C;t).
The EXPM algorithm is as follows:
Algorithm 3: EXPM
Input: Q, C, t
Output: Σ(C; t)
QC
.
0Q
Step 2: Calculate the matrix exponential eAt.
Step 3: Σ(C; t) is the upper right corner of the
matrix exponential.

Step 1: Construct A =

Testing

We implemented the presented algorithms in R and
tested them with respect to accuracy and speed.
Accuracy

The accuracy of the methods depends on the size of the
rate matrix and the time t. To investigate how these factors influence the result, we used two different CTMCs
that allow an analytical expression for (4). The first
investigation is based on the Jukes-Cantor model where
the rate matrix has uniform rates and variable size n:
⎧
⎨ −1 if i = j
1
qij =
⎩
if i = j.
n−1

if a = c, d = b
if a = c, d = b
otherwise.

We compared the result from all three methods
against the true value of (5) for size n ranging from 5 to
100, t = 0.1 and random binary matrices C. Entries in C
1
are 1 with probability . For each fixed size, we gener2
ated 5 different matrices C. The average normalized
deviation is shown in Figure 2.
The second CTMC is the HKY model:
⎛
⎞
· κπG πC πT
⎜ κπ
· πC πT ⎟
⎟
Q=⎜ A
⎝ πA πG · κπT ⎠
πA πG κπC ·
where π = (0.2,0.2,0.3,0.3) is the stationary distribution
and  = 2.15 is the transition/transversion rate ratio.
This rate matrix has an analytical result for (4) which
can be obtained through the eigenvalue decomposition.
The eigenvalues and eigenvectors of Q are
λ = (0, −1, −πY κ − πR , −πR κ − πY )
⎛
πY
πG ⎞
1−
0 −
⎜
πR
πA ⎟
⎟
⎜
πY
⎜1 −
0
1 ⎟
⎟,
⎜
πR
U=⎜
⎟
⎜ 1 1 − πT 0 ⎟
⎠
⎝
πC
1 1
1
0

where πR = πA + πG and πY = πC + πT ,
⎞
⎛
πA πG πC
πT
πC πR πT πR ⎟
⎜
⎟
⎜ −πA −πG
⎜
πY
πY ⎟
πC πC ⎟ .
U−1 = ⎜
⎟
⎜ 0
0 −
⎜
πY πY ⎟
⎠
⎝ πA πA
−
0
0
πR πR

From this, using the symbolic operations in Matlab
[20], we obtained the final analytic expression for (4).
Using this model we compared for all three methods
the true value of (5) for various values of t and randomly generated binary matrices C. For each t we generated 5 different matrices C. The average normalized
deviation is shown in Figure 2.
In both cases, all methods showed good accuracy as
the normalized deviation was no bigger than 3 × 10-9.
We also note that EXPM tended to be the most precise
while UNI provided the worst approximation. To
further investigate the accuracy, we performed calculations on randomly generated reversible rate matrices: we
first obtained the stationary distribution from the
Dirichlet distribution with shape parameters equal to 1,
then all entries qij with i ≥ j from the exponential distribution with parameter 1 and finally calculated the
remaining entries using the reversibility property. In all

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 7 of 11

Jukes-Cantor (varying n, t = 0.1)
15
×10−10

norm dev

×10−14

norm dev

9.5
4.2
-1

8
1

20

40

60

80

100

20

40

n

60

80

100

0.06
t

0.08

0.10

n

6

×10−10

norm dev

×10−11

norm dev

HKY (n = 4)

2
-2
0.04

0.06
t

0.08

0.10

3

0.02

×10−10

norm dev

×10−15

7
0

0.02

norm dev

14

1
-1

0.04

20
12
4

1

2

3

4

5

6

1

t

2

3

4

5

6

t
EVD

UNI

EXPM

Figure 2 Accuracy results. Accuracy has been tested using JC and HKY models. For each run, the normalized deviation is calculated:

ˆ (C; a, b, t) −

(C; a, b, t) / (C; a, b, t) where Σ is the correct value and ˆ is the calculated one. Each plotted point represents the

average over a, b and 5 different randomly generated matrices C as described in the main text.

the runs the relative difference between EVD, UNI and
EXPM was less than 10-5. This indicated that all three
methods have a similar performance in a wide range of
applications.
Speed

Partition of computation Assume we need to evaluate
Σ(C; t) for a fixed matrix C and multiple time points t Î
{t1,...tk}. In each iteration of the EM-algorithm in Application 1 we need this type of calculation while in order to
calculate the labeled distance in Application 2 just one
time point is required. Using EVD (Algorithm 1) we do
the eigenvalue decomposition (Step 1) once and then, for
each time point ti, we apply Step 2 and Step 3. The eigenvalue decomposition, achieved through the R function
eigen, has a running time of O(n3). In Step 2 we determine J(t) and this takes O(n2) time. Step 3 has a running
time of O(n3) due to the matrix multiplications.
If instead we apply UNI (Algorithm 2), we run Steps
1-3 for the largest time point max(ti) and then, for each
time point ti, we apply Step 4. Steps 1-3 take O (s(μmax
(ti)) n3) time, and Step 4 takes O(s(μti)n2) time for each

i Î {1,..., k}. Therefore, even though the total time for
both methods is O(n3), the addition of one time point
contributes with O(n3) for EVD, but only O(s(μt)n2) for
UNI. Recall that the constant s(μt) is the truncation
point for the infinite sum in the uniformization method.
In the case of EXPM (Algorithm 3) we need to calculate the matrix exponential at every single time point.
We used the expm R package [21] with the Higham08
method. This is a Padé approximation combined with
an improved scaling and squaring [22] and balancing
[23]. The running time is O(n3).
Table 1 provides an overview of the running times for
each of the methods. The algorithms are divided into
precomputation and main computation where the precomputation consists of steps that must be executed
only once, while in the main computation we calculate
the value of Σ(C;t) for every time point under
consideration.
Experiments We tested the speed of the algorithms in
six experiments based on the presented applications and
two more experiments using a non-reversible matrix.

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 8 of 11

Table 1 Running time complexity
Method

Table 2 Experimental design

EVD

UNI

EXPM

Steps

1

1-3

none

Order

O(n3)

O(s(μt)n3)

Precomputation

GY
Experiment

2

3

tk

μtk

s(μtk)

tk

μtk

s(μtk)

1

0.0017

0.0045

5

0.1

0.2668

8

2

Main Computation

k

0.0032

0.0085

5

0.2

0.5337

9

Steps

2-3

4

1-3

3

0.0046

0.0124

5

0.3

0.8005

11

Order

O(n3)

O(s(μt)n2)

O(n3)

4

0.0061

0.0163

5

0.4

1.0674

12

5

0.0076

0.0202

5

0.5

1.3342

13

6
7

0.0090
0.0105

0.0241
0.0281

5
6

0.6
0.7

1.6010
1.8679

14
15

8

0.0120

0.0320

6

0.8

2.1347

15

9

0.0135

0.0359

6

0.9

2.4015

16

10

0.0150

0.0398

6

1.0

2.6684

17

k

tk

μtk

s(μtk)

tk

μtk

1

0.1760

0.2668

8

0.1

0.1516

7

2

0.3520

0.5337

9

0.6

0.9098

11

3

0.5280

0.8005

11

1.1

1.6680

14

4

0.7039

1.0674

12

1.6

2.4262

16

5

0.8798

1.3342

13

2.1

3.1844

18

6

1.0558

1.6010

14

2.6

3.9426

20

7

1.2318

1.8679

15

3.1

4.7008

22

8
9

1.4077
1.5837

2.1347
2.4015

15
16

3.6
4.1

5.4590
6.2172

24
26

10

1.7597

2.6684

17

4.6

6.9754

27

k

tk

μtk

s(μtk)

tk

μtk

1

0.0379

0.1516

7

0.1

0.4

9

2

0.2275

0.9098

11

0.6

2.4

16

3
4

0.4170
0.6066

1.6680
2.4262

14
16

1.1
1.6

4.4
6.4

21
26

5

0.7961

3.1844

18

2.1

8.4

30

6

0.9857

3.9426

20

2.6

10.4

34

7

1.1752

4.7008

22

3.1

12.4

38

8

1.3648

5.4590

24

3.6

14.4

42

9

1.5543

6.2172

26

4.1

16.4

45

10

1.7439

6.9754

27

4.6

18.4

49

GY The first experiment corresponded to running the
EM algorithm on real data consisting of DNA sequences
from the HIV pol gene described in [24]. HIV has been
extensively studied with respect to selection pressure
and drug resistance and in [24] the authors document
convergent evolution in pol gene caused by drug resistance mutations. The observed data y was a multiple
codon alignment of the sequences. For simplicity, we
did not consider the columns with gaps or ambiguous
nucleotides. To compare the performance of the methods as a function of the size of the data set, we applied
the EM algorithm for 15 data sets containing from 2 up
to 16 sequences each, extracted from the HIV pol gene
data. For each set we assumed the sequences were
related according to a fixed tree; we have reconstructed
the phylogenies in Mega [25] using the Jukes-Cantor
model and Neighbor-Joining. We ran the EM algorithm
until all three parameters converged. Experiments two
and three used the previously estimated matrix Q given
by (6) with a = 10.5,  = 4.27 and ω = 0.6. We let Cij =
qij and C ii = 0, corresponding to calculating the total
number of expected substitutions E[N|t, a, b], and computed the value of Σ(C; t k ) for 10 equidistant sorted
time points tk with 1 ≤ k ≤ 10 (Table 2).
GTR In the fourth experiment we estimated the robust
labeled distance of two sequences, using the same setup as in [8]. For each considered evolutionary distance t
between 0.1 and 1, we generated 50 pairwise sequence
data sets of length 2000 which have evolved for time t
under the general time reversible (GTR) model with
⎛
⎞
· r1 πG r2 πC r3 πT
⎜r π
· r4 πC r5 πT ⎟
⎟
Q=⎜ 1 A
⎝ r2 πA r4 πG · r6 πT ⎠
r3 πA r5 πG r6 πC ·
where r = (0.5, 0.3,0.6, 0.2,0.3, 0.2) and π = (0.2,
0.2,0.3, 0.3). For labeling, we considered the jumps to
and from nucleotide A, leading to C ij = q ij if i or j
represents nucleotide A. For each data set, we estimated the GTR parameters as described in [8] and calculated the robust distance. Experiments 5 and 6 used
the same GTR matrix and Cij = qij if i or j represents
nucleotide A and zero otherwise, and computed the

GTR
Experiment

5

6
s(μtk)

UNR
Experiment

7

8
s(μtk)

The table shows the time points tk, μtk and the approximation of the Poission
tail s(μtk). For experiment 2, tk spanned the interval that contains the 10
longest branch lengths from the phylogeny of the 16 HIV pol sequences. In
experiment 3 we started at 0.1 and ended at 1. We wished to design
experiment 5 such that the corresponding s(μtk) was the same as s(μtk) from
experiment 3. This allowed us to illustrate the relative performance of the
methods when running on different sizes of the rate matrix. Experiment 6 was
done on time points starting from 0.1 and ending at 4.6. As before, we
wished to design experiment 7 such s(μtk) corresponded to experiment 6.
Experiment 8 used the same tk as experiment 6.

value of Σ(C;tk) for 10 equidistant sorted time points tk
with 1 ≤ k ≤ 10 (Table 2).
UNR In the last two experiments we used the same setup as in experiments 5 and 6 but with a different matrix

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

and time points (Table 2). As the speed of EVD is influenced by the type of the model, we decided to employ a
non-reversible matrix. We chose the unrestricted model
and carefully set the rates such that the matrix has a
complex decomposition:
⎛

⎞
−4 2 1 1
⎜ 0 −3 2 1 ⎟
⎟
Q=⎜
⎝ 1 0 −3 2 ⎠ .
2 1 1 −4

Figure 3 shows the results. For experiments 1 and 4,
the plots show the recorded running time under each
set-up (different number of sequences or different evolutionary distance). For the remaining experiments each
plot starts with the running time of the precomputation
which, for UNI, is done on the largest time point t 10.
Then, at position k, we plot the cumulative running
time for precomputation and the evaluation of Σ(C;ti)
for all i ≤ k. Since EVD and EXPM have running times
that are independent of tk, the running times for these
two algorithms are the same in experiments 2 and 3, 5
and 6, and 7 and 8. Even more, as EXPM is dependent
only on the size of the matrix, the running times in
experiments 5-8 are the same. We observe that in all
our experiments EXPM is the slowest method. Deciding
if EVD or UNI is faster depends on the size and type of
the matrix, the number of time points and the values of
s(μt). As the main computation for UNI has a running
time of O(n2) as opposed to O(n3) for EVD (Table 1),
this method should have an increased advantage when
the rate matrix is bigger. This means that if many time
points are considered, then UNI is generally the faster
method. Importantly, we note that the EVD precomputation tends to be faster than the UNI precomputation.
We remark that, in the first experiment, UNI proved to
be the fastest method while, in the fourth experiment,
UNI became slower with the increase of the evolutionary distance between the sequences and it was only faster than EVD for small distances (< 0.2). By setting tk in
an appropriate manner (Table 2), we have the same running time for UNI and EXPM for experiment 7 compared to experiment 6. Due to the fact that in
experiment 7 we used the UNR matrix, EVD is slower
as opposed to experiment 6. In this case, the difference
is observable but not very big, but as the size of the
matrix increases, this discrepancy increases too. We also
note that the difference between the reversible and nonreversible cases is enough to make UNI faster than EVD
in the latter case.

Discussion
The EVD algorithm assumes that the rate matrix is
diagonalizable. However, a direct calculation of the

Page 9 of 11

integral (4) in the non-diagonalizable case is actually
possible using the Jordan normal form for the rate
matrix. Let Q = PJP-1 where J is the Jordan normal form
of Q and P consists of the generalized eigenvectors (we
recognize that we used P and J for other quantities earlier but for this discussion this should not cause any
confusion and we prefer to use standard notation), i.e. J
has a block diagonal form J = diag(J1,..., J) where Jk =
lk I + N is a matrix with lk on the diagonal and 1 on
the superdiagonal. We have
eQt = Pdiag(eJ1 t , . . . , eJK t )P−1 ,

(26)

and noting that N is a nilpotent matrix with degree dk
(equal to the size of block Jk) we obtain
eJk t = etλk etN = eλk t I + tN +

t2 2
tdk −1
N + ... +
Ndk −1 .
2
(dk − 1)!

(27)

In order to calculate the integral (4) the expressions
(26) and (27) are used. It is evident that this procedure
is feasible but also requires much bookkeeping.
In [26] an extension of uniformization, adaptive uniformization, is described for calculating transition probabilities in a CTMC. The basic idea is to perform a local
uniformization instead of a global uniformization of the
rate matrix and thereby have fewer jumps in the jump
process. [26] considers a model with rate matrix
⎛
⎞
−3v
3v
0
0
⎜ μ −(μ + 2v)
2v
0⎟
⎟
Q=⎜
⎝ 0
μ
−(μ + v) v ⎠
0
0
0
0
(state 4 is an absorbing state). If this process starts in
state 1 then the first jump is to state 2 and the second
is from state 2 to either state 1 or state 3. This feature
can be taken into account by having a so-called adaptive
uniformized (AU) jump process where the rate for the
first jump is 3ν, for the second is μ + 2ν and, assuming
μ + ν > 3ν, the rate for the third jump is μ + ν. From
the third jump the rate in the AU jump process is μ +
2ν as in the standard uniformized jump process. The
AU jump process has a closed-form expression for the
jump probabilities (it is a pure birth process) but is of
course more complicated than a Poisson jump process.
The advantage is that the AU jump process exhibits
fewer jumps. This procedure could very well be useful
for codon models where the set of states that the process can be in after one or two jumps are limited
because only one nucleotide change is allowed in each
state change.
In an application concerned with modeling among-site
rate variation, [27] applies the uniformization procedure
(20) to calculate the transition probabilities instead of
the eigenvalue decomposition method (15). [27] shows,

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

Page 10 of 11

Goldman and Yang (n = 61)

GTR (n = 4)

Experiment 1 - Matrix estimation

Experiment 4 - Robust distance
milliseconds

seconds

3
1.5
0
2

4

6

8 10 12
# sequences

14

2
1.5
1

16

0.2

0.4
0.6
0.8
evolutionary distance
Experiment 5

milliseconds

milliseconds

Experiment 2
150
75
0

8
4
0

precomp

2

4

6

8

precomp

10

k

2

4

6

8

10

8

10

8

10

k
Experiment 6

milliseconds

Experiment 3
milliseconds

1.0

150
75
0

8
4
0

precomp

2

4

6

8

precomp

10

k

2

4

6
k

UNR (n = 4)
Experiment 8
milliseconds

milliseconds

Experiment 7
8
4
0

8
4
0

precomp

2

4

6

8

precomp

10

k
EVD

UNI

2

4

6
k

EXPM

Figure 3 Experiments results. Running times for the eight experiments. Experiment 1: rate matrix estimation using EM. The plot shows the
running time for calculating the statistics for each method, as a function of the number of sequences included in the data set. For experiments
2 and 3 we calculated the value of Σ(C;tk) for 10 time points tk. Each plot starts with the running time of the precomputation and at position k
we plot the cumulative running time for precomputation and the evaluation of Σ(C;ti) for all ti Î {t1,...,tk}. The values of tk are provided in Table 2.
Experiment 4: robust distance estimation. The plot shows the running time for computing the robust distance as a function of the evolutionary
distance t. Experiments 5-8: similar as for experiments 2 and 3 but with a GTR model (experiments 5 and 6) and UNR model (experiments 7 and
8) instead of a GY model.

in agreement with our results, that uniformization is a
faster computational method than eigenvalue
decomposition.
The presented methods are not the only ones for calculating the desired summary statistics. For example, in
[5] it is suggested to determine the expected number of
jumps from the direct calculation

pab (t)E[Ncd |t, a, b] = ∫t (eQs )ac qcd (eQ(t−s) )ac ds
0
i=0 j=0

=
=

(Qi )ac qcd (Qj )db ∫t
0

∞ ∞
k=1 t k m=0
∞

k!

k−1

si (t − s)j
ds
i!j!

(Qm )ac qcd (Qk−m−1 )db ,

where the infinite sum is truncated at k = 10. The
problem with this approach is that it is difficult to

Tataru and Hobolth BMC Bioinformatics 2011, 12:465
http://www.biomedcentral.com/1471-2105/12/465

bound the error introduced by the truncation. In UNI a
similar type of calculation applies but the truncation
error can be controlled.

Conclusion
Recall that EVD assumes that the rate matrix is diagonalizable and this constraint means that EVD is less general than the other two algorithms. We have shown in
the Discussion how a direct calculation of the integral
(4) is actually still possible but requires much bookkeeping. On top of being less general, EVD is dependent on
the type of the matrix: reversible or non-reversible. We
have shown how this discrepancy can make EVD slower
than UNI even when the state space has size of only 4.
We found that the presented methods have similar
accuracy and EXPM is the most accurate one. With
respect to running time, it is not straightforward which
method is best. We found that both the eigenvalue
decomposition (EVD) and uniformization (UNI) are faster than the matrix exponentiation method (EXPM).
The main reason for EVD and UNI being faster is that
they can be decomposed into a precomputation and a
main computation. The precomputation only depends
on the rate matrix for EVD while for UNI it also
depends on the largest time point and the matrix C. We
also remark that EXPM involves the exponentiation of a
matrix double in size. UNI is particularly fast when the
product μt is small because in this case only a few
terms in the sum (22) are needed.
Acknowledgements
We are grateful to Thomas Mailund and Julien Y. Dutheil for very useful
discussions on the presentation and implementation of the algorithms. We
would also like to thank the anonymous reviewers for constructive
comments and suggestions that helped us improve the paper.
Authors’ contributions
PT extended the existing methods to linear combinations of statistics,
implemented the algorithms and performed the testing. AH conceived the
study and guided the development and evaluation of the methods. Both
authors wrote the paper. All authors read and approved the final
manuscript.

Page 11 of 11

7.
8.

9.
10.

11.
12.
13.

14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.

26.
27.

Minin VN, Suchard MA: Fast, accurate and simulation-free stochastic
mapping. Phil Trans R Soc B 2008, 363(1512):3985-3995.
O’Brien JD, Minin VN, Suchard MA: Learning to count: robust estimates for
labeled distances between molecular sequences. Mol Biol Evol 2009,
26:801-814.
Dutheil J: Detecting site-specific biochemical constraints through
substitution mapping. J Mol Evol 2008, 67:257-65.
Siepel A, Pollard KS, Haussler D: New methods for detecting lineagespecific selection. Proceedings of the 10th International Conference on
Research in Computational Molecular Biology (RECOMB) 2006, 190-205.
Hobolth A, Jensen JL: Summary statistics for end-point conditioned
continuous-time Markov chains. J Appl Prob 2011, 48:1-14.
Van Loan CF: Computing integrals involving the matrix exponential. IEEE
Transactions on Automatic Control 1978, 23:395-404.
R Development Core Team: R: A Language and Environment for
Statistical Computing.[http://www.R-project.org], R Foundation for
Statistical Computing.
Goldman N, Yang Z: A Codon-based Model of Nucleotide Substitution for
Protein-coding DNA Sequences. Mol Biol Evol 1994, 11:725-736.
Hobolth A, Jensen JL: Statistical Inference in Evolutionary Models of DNA
Sequences via the EM Algorithm. Stat App Gen Mol Biol 2005, 4:18.
Dempster AP, Laird NM, Rubin DB: Maximum Likelihood from Incomplete
Data via the EM Algorithm. J R Statist Soc B 1977, 39:1-38.
Yap VB, Speed T: Estimating Substitution Matrices. In Statistical Methods in
Mol Evolution. Edited by: Nielsen R. Springer; 2005:420-422.
Felsenstein J: Evolutionary trees from DNA sequences: a maximum
likelihood approach. J Mol Evol 1981, 17:368-376.
Jensen A: Markov chains as an aid in the study of Markov processes.
Skand Aktuarietidskr 1953, 36:87-91.
MATLAB R2010a. Natick, Massachusetts: The MathWorks Incorporated.
Goulet V, et al: expm: Matrix exponential.[http://CRAN.R-project.org/
package=expm].
Higham J: The Scaling and Squaring Method for the Matrix Exponential
Revisited. SIAM Review 2003, 51:747-764.
Stadelmann M: Matrixfunktionen. Analyse und Implementierung. Master
thesis ETH Zurich, Mathematics Department; 2009.
Lemey P, et al: Molecular footprint of drug-selective pressure in a human
immunodeficiency virus transmission chain. J Virol 2005, 79:11981-11989.
Tamura K, et al: MEGA5: Molecular Evolutionary Genetics Analysis using
Maximum Likelihood, Evolutionary Distance, and Maximum Parsimony
Methods. Mol Biol Evol Advance Access 2011.
Van Moorsel APA, Sanders WH: Adaptive uniformization. Stochastic Models
1994, 10:619-647.
Mateiu L, Rannala B: Inferring complex DNA substitution processes on
phylogenies using uniformization and data augmentation. Systematic Biol
2006, 55:259-269.

doi:10.1186/1471-2105-12-465
Cite this article as: Tataru and Hobolth: Comparison of methods for
calculating conditional expectations of sufficient statistics for
continuous time Markov chains. BMC Bioinformatics 2011 12:465.

Received: 1 July 2011 Accepted: 5 December 2011
Published: 5 December 2011
References
1. Holmes I, Rubin GM: An expectation maximization algorithm for training
hidden substitution models. J Mol Bio 2002, 317:753-764.
2. Klosterman PS, Holmes I: XRate: a fast prototyping, training and
annotation tool for phylo-grammars. BMC Bioinf 2006, 7:428.
3. Kosiol C, Holmes I, Goldman N: An empirical codon model for protein
sequence evolution. Mol Biol Evol 2007, 24:1464-79.
4. Minin VN, Suchard MA: Counting labeled transitions in continuous-time
Markov models of evolution. J Math Biol 2008, 56:391-412.
5. Dutheil J, Pupko T, Jean-Marie A, Galtier N: A Model-Based Approach for
Detecting Co-evolving Positions in a Molecule. Mol Biol Evol 2008,
22:1919-1928.
6. Dutheil J, Galtier N: Detecting groups of co-evolving positions in a
molecule: a clustering approach. BMC Evol Biol 2007, 7:242.

Submit your next manuscript to BioMed Central
and take full advantage of:
• Convenient online submission
• Thorough peer review
• No space constraints or color ﬁgure charges
• Immediate publication on acceptance
• Inclusion in PubMed, CAS, Scopus and Google Scholar
• Research which is freely available for redistribution
Submit your manuscript at
www.biomedcentral.com/submit

</pre>
</body>
</html>
